<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Card Battle Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0c0a09;
            color: #f5f5f5;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 0.5rem;
        }

        .container {
            width: 100%;
            max-width: 800px;
            background: #1c1917;
            border: 2px solid #57534e;
            border-radius: 1rem;
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.4);
            max-height: 100vh;
            overflow-y: auto;
        }

        .health-bar-container, .mana-bar-container, .timer-bar-container {
            width: 100%;
            background-color: #44403c;
            border-radius: 0.5rem;
            overflow: hidden;
            border: 1px solid #78716c;
            position: relative;
        }

        .health-bar {
            height: 1.5rem;
            transition: width 0.5s ease-in-out, background-color 0.5s ease-in-out;
            border-radius: 0.5rem;
        }

        .health-bar.full-hp { background-color: #22c55e; }
        .health-bar.medium-hp { background-color: #eab308; }
        .health-bar.low-hp { background-color: #ef4444; }

        .mana-bar {
            height: 1.5rem;
            background-color: #6366f1;
            transition: width 0.5s ease-in-out;
            border-radius: 0.5rem;
        }
        
        .xp-bar {
            height: 0.75rem;
            background-color: #8b5cf6;
            transition: width 0.5s ease-in-out;
            border-radius: 0.5rem;
        }
        
        .bar-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.875rem;
            font-weight: bold;
            color: #f5f5f5;
        }

        .enemy-area, .player-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            gap: 0.5rem;
            flex-shrink: 0;
        }
        
        .timer-text {
            color: #a3a3a3;
            font-weight: bold;
            font-size: 0.875rem;
        }

        .player-timer-bar {
            height: 0.75rem;
            background-color: #eab308;
            transition: width 0.1s linear;
            border-radius: 0.25rem;
        }

        .enemy-icon {
            font-size: 4rem;
            color: #d6d3d1;
            animation: pulse 2s infinite ease-in-out;
        }

        .game-content {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            flex-grow: 1;
            justify-content: center;
        }
        
        .player-hand-container {
            display: flex;
            align-items: flex-end;
            gap: 1.5rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        .cards-container {
            display: flex;
            justify-content: center;
            gap: 1rem;
            flex-wrap: wrap;
            flex-shrink: 1;
        }

        .card {
            background-color: #44403c;
            border: 2px solid #57534e;
            border-radius: 0.75rem;
            padding: 1rem;
            width: 150px;
            text-align: center;
            cursor: pointer;
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 200px;
            justify-content: space-between;
        }

        .card:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.5);
        }

        .card.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            filter: grayscale(100%);
        }

        .card-icon {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
        }
        
        .card-content {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
            text-align: center;
            width: 100%;
        }

        .card-title {
            font-weight: bold;
            font-size: 1.125rem;
        }

        .card-cost {
            font-size: 0.875rem;
            color: #6366f1;
            font-weight: bold;
        }

        .damage-text {
            color: #eab308;
            font-size: 0.875rem;
        }

        .next-card-container {
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            position: relative;
        }
        
        .next-card-text {
            font-size: 0.75rem;
            color: #a3a3a3;
            text-transform: uppercase;
            font-weight: bold;
        }
        
        .next-card {
            background-color: #292524;
            border: 1px dashed #78716c;
            border-radius: 0.5rem;
            padding: 0.75rem;
            width: 120px;
            min-height: 150px;
            text-align: center;
            opacity: 0.7;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            transition: opacity 0.3s ease-in-out;
            justify-content: space-between;
        }

        .game-message {
            text-align: center;
            min-height: 2rem;
            font-size: 1.25rem;
            font-weight: bold;
        }

        .restart-button {
            padding: 0.75rem 1.5rem;
            background-color: #7c3aed;
            color: #f5f5f5;
            border: none;
            border-radius: 9999px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.1s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            margin-top: 1rem;
            align-self: center;
        }

        .restart-button:hover {
            background-color: #6d28d9;
            transform: scale(1.05);
        }

        .restart-button:active {
            transform: scale(0.95);
        }
        
        .shake {
            animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both;
            transform: translate3d(0, 0, 0);
            backface-visibility: hidden;
            perspective: 1000px;
        }
        
        .glow-green {
             box-shadow: 0 0 10px 5px rgba(34, 197, 94, 0.5);
             animation: glow-green 1.5s infinite alternate;
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background: #292524;
            padding: 2rem;
            border-radius: 1rem;
            text-align: center;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.5);
            max-width: 90%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
        }

        .modal-button {
            padding: 0.75rem 1.5rem;
            background-color: #7c3aed;
            color: #f5f5f5;
            border: none;
            border-radius: 9999px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.1s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .modal-button:hover {
            background-color: #6d28d9;
            transform: scale(1.05);
        }

        .modal-button:active {
            transform: scale(0.95);
        }

        /* Main Menu specific styles */
        .main-menu-container {
            width: 100%;
            max-width: 1000px;
            background: #1c1917;
            border: 2px solid #57534e;
            border-radius: 1rem;
            padding: 2rem;
            display: flex;
            flex-direction: column;
            gap: 2rem;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.4);
            text-align: center;
            max-height: 100vh;
            overflow-y: auto;
        }
        
        .section {
            background-color: #292524;
            border: 1px solid #44403c;
            border-radius: 0.75rem;
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            align-items: center;
            flex-grow: 1;
        }
        .section h2 {
            font-size: 1.5rem;
            font-weight: bold;
        }
        .section-button {
            padding: 0.75rem 1.5rem;
            background-color: #7c3aed;
            color: #f5f5f5;
            border: none;
            border-radius: 9999px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.1s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }
        .section-button:hover {
            background-color: #6d28d9;
            transform: scale(1.05);
        }
        .section-button:active {
            transform: scale(0.95);
        }
        #money-display {
            font-size: 2rem;
            font-weight: bold;
            color: #eab308;
        }
        .tab-buttons {
            display: flex;
            justify-content: center;
            gap: 1rem;
            width: 100%;
            margin-top: auto;
        }
        .tab-button {
            flex-grow: 1;
            padding: 0.75rem 1rem;
            background-color: #44403c;
            border-radius: 0.5rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .tab-button.active {
            background-color: #7c3aed;
        }
        .tab-content {
            display: none;
            flex-grow: 1;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            text-align: left;
        }
        .tab-content.active {
            display: flex;
        }
        /* End Main Menu specific styles */
        .card-list {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
            justify-content: center;
            width: 100%;
        }
        .deck-card {
            width: 100px;
            background-color: #292524;
            border: 1px solid #78716c;
            border-radius: 0.5rem;
            padding: 0.5rem;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.25rem;
            position: relative;
        }
        .deck-card-icon {
            font-size: 1.5rem;
            margin-bottom: 0.25rem;
        }
        .deck-card-title {
            font-size: 0.875rem;
            font-weight: bold;
        }
        .card-action-button {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background-color: #ef4444;
            color: white;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .add-card-button {
            background-color: #22c55e;
            right: auto;
            left: 5px;
        }
        .card-action-button:hover {
            opacity: 0.8;
        }

        .tooltip {
            position: absolute;
            background-color: #1c1917;
            border: 1px solid #78716c;
            color: white;
            padding: 0.75rem;
            border-radius: 0.5rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 50;
            width: 200px;
            text-align: left;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            line-height: 1.4;
        }

        .tooltip-title {
            font-weight: bold;
            font-size: 1rem;
            margin-bottom: 0.25rem;
        }
        
        .tooltip-stat {
            font-size: 0.875rem;
            color: #d6d3d1;
            margin-bottom: 0.25rem;
        }
        
        .tooltip-desc {
            font-size: 0.75rem;
            color: #a3a3a3;
        }

        .buy-button {
            padding: 0.5rem 1rem;
            background-color: #22c55e;
            color: white;
            border-radius: 9999px;
            font-size: 0.75rem;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.1s ease;
        }

        .buy-button:hover {
            transform: scale(1.05);
        }

        .buy-button:active {
            transform: scale(0.95);
        }


        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }
        
        @keyframes glow-green {
            from { box-shadow: 0 0 10px 5px rgba(34, 197, 94, 0.5); }
            to { box-shadow: 0 0 20px 10px rgba(34, 197, 94, 0.8); }
        }
        
    </style>
</head>
<body>

    <!-- Single container for all game content -->
    <div id="app-container"></div>
    <div id="tooltip" class="tooltip"></div>

    <!-- Win Modal -->
    <div id="win-modal" class="modal">
        <div class="modal-content">
            <h2 class="text-3xl font-bold">Victory!</h2>
            <p id="win-message" class="text-lg"></p>
            <p class="text-lg">You earned <span id="money-earned" class="font-bold text-yellow-400"></span>!</p>
            <p class="text-lg" id="xp-earned-message"></p>
            <p class="text-lg" id="level-up-message"></p>
            <button id="win-modal-button" class="modal-button">Go to Main Menu</button>
        </div>
    </div>

    <script type="module">
        // Global variables provided by the environment
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        let firebaseConfig = {};
        if (typeof __firebase_config !== 'undefined' && __firebase_config) {
            try {
                firebaseConfig = JSON.parse(__firebase_config);
            } catch (e) {
                console.error("Failed to parse firebase config:", e);
            }
        }
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Firestore and Auth imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInWithCustomToken, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, runTransaction, onSnapshot, setDoc, updateDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // Log all Firestore actions to the console for debugging
        setLogLevel('debug');
        
        // Initialize Firebase
        let app, db, auth;
        let isFirebaseActive = false;
        if (Object.keys(firebaseConfig).length > 0) {
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
            isFirebaseActive = true;
        } else {
            console.warn("Firebase config not found. Running in offline mode.");
        }
        
        let userId = 'offline-user-' + crypto.randomUUID();

        // --- DOM Elements & Content Generation ---
        const appContainer = document.getElementById('app-container');
        const winModal = document.getElementById('win-modal');
        const winMessage = document.getElementById('win-message');
        const moneyEarned = document.getElementById('money-earned');
        const winModalButton = document.getElementById('win-modal-button');
        const tooltip = document.getElementById('tooltip');

        // Main Menu Content
        function createMainMenu() {
            return `
                <div id="main-menu-page" class="main-menu-container">
                    <h1 class="text-3xl font-bold mb-4">Main Menu</h1>
                    <div id="tab-content-container" class="flex flex-col flex-grow w-full gap-4">
                        <div id="stats-section" class="tab-content active">
                            <div class="section">
                                <h2>Your Stats</h2>
                                <div class="w-full flex flex-col gap-2 items-center">
                                    <p id="money-display" class="text-xl">Money: Loading...</p>
                                    <p id="level-display" class="text-xl">Level: Loading...</p>
                                    <div class="w-full flex flex-col gap-1 items-center">
                                        <p id="xp-display" class="text-sm">XP: Loading...</p>
                                        <div class="health-bar-container w-1/2">
                                            <div id="xp-bar" class="xp-bar" style="width: 0%;"></div>
                                        </div>
                                    </div>
                                    <hr class="border-t border-gray-700 w-full my-4">
                                    <h3 class="text-lg font-bold">Upgrades</h3>
                                    <div class="w-full flex flex-col gap-2 items-center">
                                        <div class="w-full bg-gray-700 rounded-md p-2 flex justify-between items-center">
                                            <span>Damage: +<span id="damage-upgrade-level">0</span></span>
                                            <button id="upgrade-damage-button" class="buy-button">Upgrade (<span id="damage-upgrade-cost"></span>)</button>
                                        </div>
                                        <div class="w-full bg-gray-700 rounded-md p-2 flex justify-between items-center">
                                            <span>Health: +<span id="hp-upgrade-level">0</span></span>
                                            <button id="upgrade-hp-button" class="buy-button">Upgrade (<span id="hp-upgrade-cost"></span>)</button>
                                        </div>
                                    </div>
                                </div>
                                <p class="text-sm">User ID: ${isFirebaseActive ? userId : 'Offline Mode'}</p>
                            </div>
                        </div>
                        <div id="enemies-section" class="tab-content">
                            <div class="section">
                                <h2>Enemies</h2>
                                <div id="enemies-list" class="grid grid-cols-2 gap-4"></div>
                            </div>
                        </div>
                        <div id="deck-section" class="tab-content">
                            <div class="section flex-col items-start gap-4">
                                <h2 class="w-full text-center">Your Deck</h2>
                                <div id="in-deck-container" class="w-full">
                                    <h3 class="font-bold mb-2">In Deck (${userDeck.length}/${DECK_MAX_SIZE})</h3>
                                    <div class="card-list" id="in-deck-cards"></div>
                                </div>
                                <div id="owned-container" class="w-full">
                                    <h3 class="font-bold mb-2">Owned</h3>
                                    <div class="card-list" id="owned-cards"></div>
                                </div>
                                <div id="not-owned-container" class="w-full">
                                    <h3 class="font-bold mb-2">Not Owned Yet</h3>
                                    <div class="card-list" id="not-owned-cards"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="tab-buttons">
                        <button id="stats-tab-button" class="tab-button active">Stats</button>
                        <button id="enemies-tab-button" class="tab-button">Enemies</button>
                        <button id="deck-tab-button" class="tab-button">Deck</button>
                    </div>
                </div>
            `;
        }

        // Game Page Content
        function createGamePage() {
            return `
                <div id="game-page" class="container">
                    <div class="enemy-area">
                        <i id="enemy-icon" class="enemy-icon"></i>
                        <h2 id="enemy-name" class="text-2xl font-bold"></h2>
                        <div class="health-bar-container">
                            <div id="enemy-health-bar" class="health-bar full-hp" style="width: 100%;"></div>
                            <span id="enemy-health-text" class="bar-text"></span>
                        </div>
                    </div>
                    <hr class="border-t border-gray-700 w-full my-4">
                    <div class="game-content">
                        <p id="game-message" class="game-message text-center italic"></p>
                        <div class="player-hand-container">
                            <div id="player-hand" class="cards-container"></div>
                            <div class="next-card-container">
                                <p class="next-card-text">Next Card</p>
                                <div id="next-card-display" class="next-card"></div>
                            </div>
                        </div>
                        <div class="player-area mt-4">
                            <span id="player-timer-text" class="timer-text">Time to Act: 10s</span>
                            <div class="timer-bar-container">
                                <div id="player-timer-bar" class="player-timer-bar" style="width: 100%;"></div>
                            </div>
                        </div>
                    </div>
                    <hr class="border-t border-gray-700 w-full my-4">
                    <div class="player-area">
                        <h2 class="text-2xl font-bold">You</h2>
                        <div class="health-bar-container">
                            <div id="player-health-bar" class="health-bar full-hp" style="width: 100%;"></div>
                            <span id="player-health-text" class="bar-text"></span>
                        </div>
                        <div class="mana-bar-container">
                            <div id="mana-bar" class="mana-bar" style="width: 100%;"></div>
                            <span id="mana-text" class="bar-text"></span>
                        </div>
                    </div>
                </div>
            `;
        }
        
        // --- Game Logic & State ---
        const STARTING_HEALTH = 100;
        const MAX_MANA = 10;
        const MANA_REGEN_TIME = 1.56;
        const INACTIVITY_TIMER_MAX = 10;
        
        let playerHealth = STARTING_HEALTH;
        let currentPlayerMaxHealth = STARTING_HEALTH;
        let playerMana = 0;
        let enemyHealth = 0;
        let gameActive = true;
        let isEnemyStunned = false;
        let nextAttackBoost = 0;
        let enemyDamageReduction = 0;
        let isVulnerable = false;
        let deck = [];
        let hand = [];
        const HAND_SIZE = 3;
        const DECK_MAX_SIZE = 8;
        let currentEnemy = null;
        
        let playerActionTimer = 0;
        let gameLoopInterval;
        let enemyAttackTimeout;
        let userDeck = [];
        let userOwnedCards = [];
        let userMoney = 0;
        let userLevel = 1;
        let userXp = 0;
        let xpToNextLevel = 100;
        let damageUpgradeLevel = 0;
        let hpUpgradeLevel = 0;

        const allCards = [
            { id: 1, name: 'Punch', icon: 'fa-solid fa-fist-raised', color: 'text-red-500', damage: { min: 4, max: 8 }, manaCost: 1, effect: 'none', description: 'A basic, but reliable attack.', purchaseCost: 0, requiredLevel: 1 },
            { id: 2, name: 'Feint', icon: 'fa-solid fa-hand-dots', color: 'text-purple-400', damage: { min: 0, max: 0 }, manaCost: 2, effect: 'weaken', description: 'A quick move that distracts the enemy, reducing their next attack damage.', purchaseCost: 0, requiredLevel: 1 },
            { id: 3, name: 'Heavy Swing', icon: 'fa-solid fa-hammer', color: 'text-yellow-500', damage: { min: 10, max: 14 }, manaCost: 3, effect: 'none', description: 'A powerful attack.', purchaseCost: 0, requiredLevel: 1 },
            { id: 4, name: 'Heal Potion', icon: 'fa-solid fa-flask', color: 'text-green-500', damage: { min: 5, max: 8 }, manaCost: 4, effect: 'heal', description: 'Drink a potion to heal yourself.', purchaseCost: 0, requiredLevel: 1 },
            { id: 5, name: 'Stone Throw', icon: 'fa-solid fa-hand-rock', color: 'text-stone-400', damage: { min: 5, max: 10 }, manaCost: 2, effect: 'none', description: 'Throw a rock at the enemy.', purchaseCost: 0, requiredLevel: 1 },
            { id: 6, name: 'Guard', icon: 'fa-solid fa-shield-alt', color: 'text-cyan-500', damage: { min: 0, max: 0 }, manaCost: 3, effect: 'block', description: 'Block the next attack.', purchaseCost: 0, requiredLevel: 1 },
            { id: 7, name: 'Siphon Strike', icon: 'fa-solid fa-hand-sparkles', color: 'text-purple-500', damage: { min: 4, max: 7 }, manaCost: 3, effect: 'siphon', description: 'Strike and regain a small amount of health.', purchaseCost: 0, requiredLevel: 1 },
            { id: 8, name: 'Power Up', icon: 'fa-solid fa-star', color: 'text-yellow-300', damage: { min: 0, max: 0 }, manaCost: 2, effect: 'boost', description: 'Increases the damage of your next attack.', purchaseCost: 0, requiredLevel: 1 },
            { id: 9, name: 'Vulnerability', icon: 'fa-solid fa-crosshairs', color: 'text-red-500', damage: { min: 0, max: 0 }, manaCost: 4, effect: 'vulnerable', description: 'The enemy takes 15% more damage from your next attack.', purchaseCost: 280, requiredLevel: 1 },
            { id: 10, name: 'Vitality Boost', icon: 'fa-solid fa-plus-circle', color: 'text-lime-500', damage: { min: 10, max: 15 }, manaCost: 5, effect: 'vitalityBoost', description: 'Heals you and increases your max HP for this fight.', purchaseCost: 275, requiredLevel: 1 },
            { id: 11, name: 'Berserk', icon: 'fa-solid fa-skull-crossbones', color: 'text-red-700', damage: { min: 20, max: 25 }, manaCost: 4, effect: 'berserk', description: 'A high-risk, high-reward attack that damages you as well.', purchaseCost: 300, requiredLevel: 1 },
            { id: 12, name: 'Precision Strike', icon: 'fa-solid fa-bullseye', color: 'text-cyan-400', damage: { min: 12, max: 15 }, manaCost: 5, effect: 'precision', description: 'A critical strike that bypasses the enemy\'s defense.', purchaseCost: 310, requiredLevel: 1 },
            { id: 13, name: 'Shadow Step', icon: 'fa-solid fa-ghost', color: 'text-purple-700', damage: { min: 0, max: 0 }, manaCost: 6, effect: 'shadowStep', description: 'Become invulnerable to the enemy\'s next attack.', purchaseCost: 335, requiredLevel: 1 },
            // New Cards - Tier 1
            { id: 14, name: 'Thorns', icon: 'fa-solid fa-thorns', color: 'text-lime-500', damage: { min: 0, max: 0 }, manaCost: 3, effect: 'thorns', description: 'Gains 5 thorns, damaging enemies on hit.', purchaseCost: 250, requiredLevel: 1 },
            { id: 15, name: 'Fortify', icon: 'fa-solid fa-fort-awesome', color: 'text-stone-400', damage: { min: 0, max: 0 }, manaCost: 4, effect: 'fortify', description: 'Heals you and gives a shield.', purchaseCost: 275, requiredLevel: 1 },
            { id: 16, name: 'Mana Steal', icon: 'fa-solid fa-magic', color: 'text-purple-500', damage: { min: 3, max: 5 }, manaCost: 2, effect: 'manaSteal', description: 'Deals damage and siphons enemy mana.', purchaseCost: 300, requiredLevel: 1 },
            { id: 17, name: 'Chain Lightning', icon: 'fa-solid fa-bolt', color: 'text-yellow-300', damage: { min: 5, max: 7 }, manaCost: 4, effect: 'chainLightning', description: 'Deals damage and hits all enemies.', purchaseCost: 325, requiredLevel: 1 },
            { id: 18, name: 'Explosion', icon: 'fa-solid fa-bomb', color: 'text-red-700', damage: { min: 25, max: 35 }, manaCost: 6, effect: 'explosion', description: 'Deals massive damage to all enemies.', purchaseCost: 350, requiredLevel: 1 },
            // New Cards - Tier 2
            { id: 19, name: 'Frost Blast', icon: 'fa-solid fa-snowflake', color: 'text-cyan-400', damage: { min: 10, max: 15 }, manaCost: 5, effect: 'frostBlast', description: 'Freezes enemy, making them not attack next turn.', purchaseCost: 450, requiredLevel: 5 },
            { id: 20, name: 'Poison Cloud', icon: 'fa-solid fa-flask-poison', color: 'text-green-500', damage: { min: 0, max: 0 }, manaCost: 4, effect: 'poisonCloud', description: 'Poisons enemy, dealing damage over time.', purchaseCost: 475, requiredLevel: 5 },
            { id: 21, name: 'Holy Light', icon: 'fa-solid fa-star-of-life', color: 'text-yellow-300', damage: { min: 0, max: 0 }, manaCost: 5, effect: 'holyLight', description: 'Heals all allies and gives a shield.', purchaseCost: 500, requiredLevel: 5 },
            { id: 22, name: 'Shadow Clone', icon: 'fa-solid fa-users-cog', color: 'text-purple-700', damage: { min: 0, max: 0 }, manaCost: 6, effect: 'shadowClone', description: 'Creates a clone to fight for you for 2 turns.', purchaseCost: 525, requiredLevel: 5 },
            { id: 23, name: 'Arcane Missiles', icon: 'fa-solid fa-meteor', color: 'text-blue-500', damage: { min: 5, max: 8 }, manaCost: 3, effect: 'arcaneMissiles', description: 'Fires 3 missiles at the enemy.', purchaseCost: 550, requiredLevel: 5 },
            // New Cards - Tier 3
            { id: 24, name: 'Bloodlust', icon: 'fa-solid fa-blood-droplet', color: 'text-red-700', damage: { min: 15, max: 20 }, manaCost: 6, effect: 'bloodlust', description: 'A powerful attack that steals health from the enemy.', purchaseCost: 575, requiredLevel: 10 },
            { id: 25, name: 'Divine Shield', icon: 'fa-solid fa-sun-plant-wilt', color: 'text-yellow-300', damage: { min: 0, max: 0 }, manaCost: 8, effect: 'divineShield', description: 'A powerful shield that blocks all damage for 2 turns.', purchaseCost: 600, requiredLevel: 10 },
            { id: 26, name: 'Meteor', icon: 'fa-solid fa-volcano', color: 'text-red-500', damage: { min: 30, max: 40 }, manaCost: 10, effect: 'meteor', description: 'Deals massive damage to all enemies.', purchaseCost: 625, requiredLevel: 10 },
            { id: 27, name: 'Time Warp', icon: 'fa-solid fa-clock', color: 'text-cyan-400', damage: { min: 0, max: 0 }, manaCost: 10, effect: 'timeWarp', description: 'Rewinds time, giving you another turn.', purchaseCost: 650, requiredLevel: 10 },
            { id: 28, name: 'Soul Harvest', icon: 'fa-solid fa-ghost', color: 'text-purple-700', damage: { min: 5, max: 8 }, manaCost: 4, effect: 'soulHarvest', description: 'Deals damage and gains health for each mana spent.', purchaseCost: 675, requiredLevel: 10 },
            // New Cards - Tier 4
            { id: 29, name: 'Chaos Bolt', icon: 'fa-solid fa-fire-alt', color: 'text-orange-500', damage: { min: 35, max: 50 }, manaCost: 8, effect: 'chaosBolt', description: 'Deals massive, unpredictable damage.', purchaseCost: 700, requiredLevel: 15 },
            { id: 30, name: 'Resurrection', icon: 'fa-solid fa-heart', color: 'text-red-500', damage: { min: 0, max: 0 }, manaCost: 10, effect: 'resurrection', description: 'Revives you with a small amount of health.', purchaseCost: 725, requiredLevel: 15 },
            { id: 31, name: 'Exorcism', icon: 'fa-solid fa-cross', color: 'text-yellow-300', damage: { min: 20, max: 30 }, manaCost: 7, effect: 'exorcism', description: 'Deals extra damage to undead enemies.', purchaseCost: 750, requiredLevel: 15 },
            { id: 32, name: 'Summon Demon', icon: 'fa-solid fa-dragon', color: 'text-purple-700', damage: { min: 0, max: 0 }, manaCost: 10, effect: 'summonDemon', description: 'Summons a demon to fight for you.', purchaseCost: 775, requiredLevel: 15 },
            { id: 33, name: 'Black Hole', icon: 'fa-solid fa-black-hole', color: 'text-gray-800', damage: { min: 50, max: 75 }, manaCost: 15, effect: 'blackHole', description: 'Deals devastating damage to all enemies.', purchaseCost: 800, requiredLevel: 15 }
        ];

        
        const enemies = {
            bandit: {
                name: "Bandit",
                icon: "fas fa-user-secret",
                health: 50,
                xpReward: 25,
                attacks: [
                    { name: "Pistol Shot", damage: { min: 5, max: 10 } },
                    { name: "Quick Stab", damage: { min: 3, max: 6 } },
                ]
            },
            goblin: {
                name: "Goblin",
                icon: "fas fa-skull",
                health: 40,
                xpReward: 40,
                attacks: [
                    { name: "Foul Bite", damage: { min: 8, max: 12 } },
                    { name: "Scuttle", damage: { min: 2, max: 4 } },
                ]
            },
            sorcerer: {
                name: "Sorcerer",
                icon: "fas fa-hat-wizard",
                health: 60,
                xpReward: 75,
                attacks: [
                    { name: "Fireball", damage: { min: 15, max: 20 } },
                    { name: "Arcane Bolt", damage: { min: 10, max: 15 } },
                ]
            }
        };


        function getRandomDamage(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        const getDamageUpgradeBonus = (level) => level * 2;
        const getHpUpgradeBonus = (level) => level * 10;
        const getUpgradeCost = (level) => 1000 + (level * 500);
        
        function shuffleDeck() {
            deck = userDeck.map(cardId => allCards.find(card => card.id === cardId));
            if (deck.length > 0) {
                for (let i = deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [deck[i], deck[j]] = [deck[j], deck[i]];
                }
            } else {
                deck = [];
            }
        }

        function dealCards() {
            hand = [];
            for (let i = 0; i < HAND_SIZE; i++) {
                if (deck.length > 0) {
                    hand.push(deck.shift());
                }
            }
        }
        
        // Tooltip functions
        function showTooltip(event, card) {
            const damageText = card.effect === 'heal' || card.effect === 'vitalityBoost' ? `Heal: ${card.damage.min}-${card.damage.max}` :
                               (card.damage.min !== 0 || card.damage.max !== 0) ? `Damage: ${card.damage.min}-${card.damage.max}` :
                               '';
            const requiredLevelText = card.requiredLevel > 1 ? `Required Level: ${card.requiredLevel}` : '';

            tooltip.innerHTML = `
                <div class="tooltip-title">${card.name}</div>
                <div class="tooltip-stat">Cost: ${card.manaCost} Mana</div>
                ${damageText ? `<div class="tooltip-stat">${damageText}</div>` : ''}
                ${requiredLevelText ? `<div class="tooltip-stat">${requiredLevelText}</div>` : ''}
                <div class="tooltip-desc">${card.description}</div>
            `;
            tooltip.style.left = `${event.clientX + 15}px`;
            tooltip.style.top = `${event.clientY + 15}px`;
            tooltip.style.opacity = '1';
        }
        
        function hideTooltip() {
            tooltip.style.opacity = '0';
        }

        function renderCards() {
            const playerHandContainer = document.getElementById('player-hand');
            const nextCardDisplay = document.getElementById('next-card-display');
            if (!playerHandContainer || !nextCardDisplay) return;

            playerHandContainer.innerHTML = '';
            hand.forEach((card) => {
                const cardDiv = document.createElement('div');
                cardDiv.id = `card-${card.id}`;
                cardDiv.classList.add('card');
                
                if (playerMana < card.manaCost) {
                    cardDiv.classList.add('disabled');
                }
                
                const cardIcon = document.createElement('i');
                card.icon.split(' ').forEach(cls => cardIcon.classList.add(cls));
                cardIcon.classList.add('card-icon', card.color);
                
                const cardContentDiv = document.createElement('div');
                cardContentDiv.classList.add('card-content');
                
                const cardTitle = document.createElement('span');
                cardTitle.classList.add('card-title');
                cardTitle.textContent = card.name;
                
                const cardCost = document.createElement('span');
                cardCost.classList.add('card-cost');
                cardCost.textContent = `Cost: ${card.manaCost} Mana`;
                
                let damageText = document.createElement('span');
                damageText.classList.add('damage-text');
                if (card.effect === 'heal' || card.effect === 'vitalityBoost') {
                    damageText.textContent = `Heal: ${card.damage.min}-${card.damage.max}`;
                } else if (card.damage.min !== 0 || card.damage.max !== 0) {
                    damageText.textContent = `Damage: ${card.damage.min}-${card.damage.max}`;
                }

                const cardDescription = document.createElement('p');
                cardDescription.classList.add('text-xs', 'text-gray-400');
                cardDescription.textContent = card.description;

                cardContentDiv.appendChild(cardTitle);
                cardContentDiv.appendChild(cardCost);
                cardContentDiv.appendChild(damageText);
                cardContentDiv.appendChild(cardDescription);
                
                cardDiv.appendChild(cardIcon);
                cardDiv.appendChild(cardContentDiv);
                
                cardDiv.addEventListener('click', () => handleCardClick(card));
                cardDiv.addEventListener('mousemove', (e) => showTooltip(e, card));
                cardDiv.addEventListener('mouseout', hideTooltip);

                playerHandContainer.appendChild(cardDiv);
            });
            
            nextCardDisplay.innerHTML = '';
            if (deck.length > 0) {
                const nextCard = deck[0];
                const nextCardIcon = document.createElement('i');
                nextCard.icon.split(' ').forEach(cls => nextCardIcon.classList.add(cls));
                nextCardIcon.classList.add('card-icon', nextCard.color);
                
                const nextCardTitle = document.createElement('span');
                nextCardTitle.classList.add('card-title', 'text-sm', 'text-gray-400');
                nextCardTitle.textContent = nextCard.name;
                nextCardDisplay.appendChild(nextCardIcon);
                nextCardDisplay.appendChild(nextCardTitle);
            }
        }

        function updateCardStates() {
            const cardElements = document.querySelectorAll('#player-hand .card');
            cardElements.forEach(cardEl => {
                const cardId = parseInt(cardEl.id.replace('card-', ''));
                const card = hand.find(c => c.id === cardId);
                if (card) {
                    if (playerMana < card.manaCost) {
                        cardEl.classList.add('disabled');
                    } else {
                        cardEl.classList.remove('disabled');
                    }
                }
            });
        }

        function updateUI() {
            const enemyHealthBar = document.getElementById('enemy-health-bar');
            const enemyHealthText = document.getElementById('enemy-health-text');
            const enemyIcon = document.getElementById('enemy-icon');
            const enemyName = document.getElementById('enemy-name');
            
            const playerHealthBar = document.getElementById('player-health-bar');
            const playerHealthText = document.getElementById('player-health-text');
            const manaBar = document.getElementById('mana-bar');
            const manaText = document.getElementById('mana-text');
            const playerTimerText = document.getElementById('player-timer-text');
            const playerTimerBar = document.getElementById('player-timer-bar');

            if (!enemyHealthBar || !playerHealthBar || !manaBar) return;
            
            // Update enemy UI based on current enemy
            if (currentEnemy) {
                enemyName.textContent = currentEnemy.name;
                enemyIcon.className = ''; // Clear previous classes
                currentEnemy.icon.split(' ').forEach(cls => enemyIcon.classList.add(cls));
                enemyIcon.classList.add('enemy-icon');
            }

            const enemyHealthPercentage = (enemyHealth / currentEnemy.health) * 100;
            enemyHealthBar.style.width = `${Math.max(0, enemyHealthPercentage)}%`;
            enemyHealthText.textContent = `${Math.max(0, Math.ceil(enemyHealth))} / ${currentEnemy.health} HP`;

            const playerHealthPercentage = (playerHealth / currentPlayerMaxHealth) * 100;
            playerHealthBar.style.width = `${Math.max(0, playerHealthPercentage)}%`;
            playerHealthText.textContent = `${Math.max(0, Math.ceil(playerHealth))} / ${currentPlayerMaxHealth} HP`;

            const manaPercentage = (playerMana / MAX_MANA) * 100;
            manaBar.style.width = `${Math.max(0, manaPercentage)}%`;
            manaText.textContent = `${Math.floor(playerMana)} Mana`;

            const timerPercentage = (playerActionTimer / INACTIVITY_TIMER_MAX) * 100;
            playerTimerBar.style.width = `${Math.max(0, timerPercentage)}%`;
            playerTimerText.textContent = `Time to Act: ${Math.floor(INACTIVITY_TIMER_MAX - playerActionTimer)}s`;
            
            enemyHealthBar.classList.remove('full-hp', 'medium-hp', 'low-hp');
            playerHealthBar.classList.remove('full-hp', 'medium-hp', 'low-hp');
            if (enemyHealthPercentage > 50) enemyHealthBar.classList.add('full-hp');
            else if (enemyHealthPercentage > 20) enemyHealthBar.classList.add('medium-hp');
            else enemyHealthBar.classList.add('low-hp');
            
            if (playerHealthPercentage > 50) playerHealthBar.classList.add('full-hp');
            else if (playerHealthPercentage > 20) playerHealthBar.classList.add('medium-hp');
            else playerHealthBar.classList.add('low-hp');
        }

        function showMessage(message) {
            const gameMessage = document.getElementById('game-message');
            if (gameMessage) gameMessage.textContent = message;
        }

        function shakeElement(elementId) {
            const element = document.getElementById(elementId);
            if (!element) return;
            element.classList.add('shake');
            setTimeout(() => {
                element.classList.remove('shake');
            }, 500);
        }

        function handleCardClick(cardPlayed) {
            if (!gameActive || playerMana < cardPlayed.manaCost) return;
            
            playerMana -= cardPlayed.manaCost;
            playerActionTimer = 0;
            
            let damageDealt = getRandomDamage(cardPlayed.damage.min, cardPlayed.damage.max) + nextAttackBoost + getDamageUpgradeBonus(damageUpgradeLevel);
            if (isVulnerable) {
                damageDealt = Math.floor(damageDealt * 1.15);
                isVulnerable = false;
            }
            nextAttackBoost = 0;
            
            let message = `You played ${cardPlayed.name}! `;

            switch(cardPlayed.effect) {
                case 'heal':
                    const healAmount = getRandomDamage(cardPlayed.damage.min, cardPlayed.damage.max);
                    playerHealth = Math.min(currentPlayerMaxHealth, playerHealth + healAmount);
                    message += `You healed for ${healAmount} HP.`;
                    break;
                case 'vitalityBoost':
                    const vitalityHeal = getRandomDamage(cardPlayed.damage.min, cardPlayed.damage.max);
                    currentPlayerMaxHealth += 10;
                    playerHealth = Math.min(currentPlayerMaxHealth, playerHealth + vitalityHeal);
                    message += `You healed for ${vitalityHeal} HP and increased your max health!`;
                    break;
                case 'stun':
                    enemyHealth -= damageDealt;
                    isEnemyStunned = true;
                    message += `You dealt ${damageDealt} damage and stunned the enemy for their next turn!`;
                    shakeElement('enemy-health-bar');
                    break;
                case 'siphon':
                    enemyHealth -= damageDealt;
                    playerHealth = Math.min(currentPlayerMaxHealth, playerHealth + Math.floor(damageDealt / 2));
                    message += `You dealt ${damageDealt} damage and siphoned ${Math.floor(damageDealt/2)} HP!`;
                    shakeElement('enemy-health-bar');
                    break;
                case 'boost':
                    nextAttackBoost = 5;
                    damageDealt = getRandomDamage(cardPlayed.damage.min, cardPlayed.damage.max);
                    enemyHealth -= damageDealt;
                    message += `You dealt ${damageDealt} damage! Your next attack will deal an extra ${nextAttackBoost} damage!`;
                    shakeElement('enemy-health-bar');
                    break;
                case 'block':
                    isEnemyStunned = true;
                    damageDealt = 0;
                    message += `You prepare a shield to block the enemy's next attack!`;
                    shakeElement('player-health-bar');
                    break;
                case 'weaken':
                    enemyDamageReduction = 4;
                    damageDealt = 0;
                    message += `You feint, making the Bandit's next attack weaker!`;
                    break;
                case 'vulnerable':
                    isVulnerable = true;
                    damageDealt = 0;
                    message += `You made the Bandit vulnerable! Your next attack will deal more damage.`;
                    break;
                case 'berserk':
                    enemyHealth -= damageDealt;
                    playerHealth = Math.max(0, playerHealth - 5);
                    message += `You dealt ${damageDealt} damage, but took 5 damage yourself!`;
                    shakeElement('enemy-health-bar');
                    shakeElement('player-health-bar');
                    break;
                case 'precision':
                    enemyHealth -= damageDealt;
                    message += `You dealt a precise ${damageDealt} damage, bypassing their defense!`;
                    shakeElement('enemy-health-bar');
                    break;
                case 'shadowStep':
                    isEnemyStunned = true; // Use stun logic to skip their turn
                    damageDealt = 0;
                    message += `You vanished into the shadows, the Bandit's next attack will miss!`;
                    shakeElement('player-health-bar');
                    break;
                case 'thorns':
                    // This is handled in the enemyTurn() function.
                    message += `You gain 5 thorns!`;
                    break;
                case 'fortify':
                    // This is handled in the enemyTurn() function.
                    message += `You gain a shield and heal yourself!`;
                    break;
                case 'manaSteal':
                    // This is handled in the enemyTurn() function.
                    message += `You deal ${damageDealt} damage and steal enemy mana!`;
                    break;
                case 'chainLightning':
                    // This is handled in the enemyTurn() function.
                    message += `You deal ${damageDealt} damage to all enemies!`;
                    break;
                case 'explosion':
                    // This is handled in the enemyTurn() function.
                    message += `You deal massive damage to all enemies!`;
                    break;
                case 'frostBlast':
                    // This is handled in the enemyTurn() function.
                    message += `You freeze the enemy!`;
                    break;
                case 'poisonCloud':
                    // This is handled in the enemyTurn() function.
                    message += `You poison the enemy!`;
                    break;
                case 'holyLight':
                    // This is handled in the enemyTurn() function.
                    message += `You heal all allies and gain a shield!`;
                    break;
                case 'shadowClone':
                    // This is handled in the enemyTurn() function.
                    message += `You summon a shadow clone!`;
                    break;
                case 'arcaneMissiles':
                    // This is handled in the enemyTurn() function.
                    message += `You fire 3 missiles at the enemy!`;
                    break;
                case 'bloodlust':
                    // This is handled in the enemyTurn() function.
                    message += `You steal health from the enemy!`;
                    break;
                case 'divineShield':
                    // This is handled in the enemyTurn() function.
                    message += `You gain a divine shield!`;
                    break;
                case 'meteor':
                    // This is handled in the enemyTurn() function.
                    message += `You summon a meteor!`;
                    break;
                case 'timeWarp':
                    // This is handled in the enemyTurn() function.
                    message += `You rewind time and gain another turn!`;
                    break;
                case 'soulHarvest':
                    // This is handled in the enemyTurn() function.
                    message += `You harvest a soul and gain health!`;
                    break;
                case 'chaosBolt':
                    // This is handled in the enemyTurn() function.
                    message += `You fire a chaos bolt!`;
                    break;
                case 'resurrection':
                    // This is handled in the enemyTurn() function.
                    message += `You resurrect with a small amount of health!`;
                    break;
                case 'exorcism':
                    // This is handled in the enemyTurn() function.
                    message += `You exorcise the enemy!`;
                    break;
                case 'summonDemon':
                    // This is handled in the enemyTurn() function.
                    message += `You summon a demon!`;
                    break;
                case 'blackHole':
                    // This is handled in the enemyTurn() function.
                    message += `You summon a black hole!`;
                    break;
                default:
                    enemyHealth -= damageDealt;
                    message += `You dealt ${damageDealt} damage!`;
                    shakeElement('enemy-health-bar');
                    break;
            }

            const cardIndex = hand.findIndex(c => c.id === cardPlayed.id);
            if (cardIndex > -1) {
                const usedCard = hand.splice(cardIndex, 1)[0];
                deck.push(usedCard);
            }
            if (deck.length > 0) {
                 hand.push(deck.shift());
            }
            
            updateUI();
            renderCards();
            showMessage(message);

            if (enemyHealth <= 0) {
                endGame("Victory! You have defeated the " + currentEnemy.name + "!", true);
                return;
            }
            
            clearTimeout(enemyAttackTimeout);
            enemyAttackTimeout = setTimeout(() => {
                enemyTurn();
            }, 2000);
        }

        function enemyTurn() {
            if (isEnemyStunned) {
                showMessage(`The ${currentEnemy.name} is stunned and cannot move!`);
                isEnemyStunned = false;
            } else if (gameActive) {
                const enemyAttack = currentEnemy.attacks[Math.floor(Math.random() * currentEnemy.attacks.length)];
                const enemyDamage = Math.max(1, getRandomDamage(enemyAttack.damage.min, enemyAttack.damage.max) - enemyDamageReduction);
                playerHealth -= enemyDamage;
                enemyDamageReduction = 0;
                updateUI();
                showMessage(`The ${currentEnemy.name} uses ${enemyAttack.name} and deals ${enemyDamage} damage!`);
                shakeElement('player-health-bar');
            }
            
            if (playerHealth <= 0) {
                endGame(`Defeat! The ${currentEnemy.name} has overwhelmed you.`, false);
            }
        }

        function gameLoop() {
            if (!gameActive) return;

            playerMana = Math.min(MAX_MANA, playerMana + (1 / MANA_REGEN_TIME) * 0.1);

            playerActionTimer += 0.1;
            if (playerActionTimer >= INACTIVITY_TIMER_MAX) {
                showMessage("You took too long! The Bandit attacks!");
                enemyTurn();
                playerActionTimer = 0;
            }

            updateUI();
            updateCardStates();
        }
        
        function startGame(enemyId) {
            currentEnemy = enemies[enemyId];
            if (!currentEnemy) {
                console.error("Invalid enemy selected:", enemyId);
                return;
            }
            
            // Re-initialize all game-specific state
            const damageBonus = getDamageUpgradeBonus(damageUpgradeLevel);
            const hpBonus = getHpUpgradeBonus(hpUpgradeLevel);
            
            playerHealth = STARTING_HEALTH + hpBonus;
            currentPlayerMaxHealth = STARTING_HEALTH + hpBonus;
            playerMana = 0;
            enemyHealth = currentEnemy.health;
            gameActive = true;
            isEnemyStunned = false;
            nextAttackBoost = 0;
            enemyDamageReduction = 0;
            playerActionTimer = 0;
            
            // Populate deck from Firestore data
            shuffleDeck();
            dealCards();
            
            // Set up UI and game loop
            appContainer.innerHTML = createGamePage();
            updateUI();
            renderCards();
            showMessage(`A new battle begins against the ${currentEnemy.name}!`);
            
            if (gameLoopInterval) clearInterval(gameLoopInterval);
            gameLoopInterval = setInterval(gameLoop, 100);
        }
        
        async function endGame(message, didWin) {
            gameActive = false;
            clearInterval(gameLoopInterval);
            
            if (didWin) {
                const moneyGained = getRandomDamage(50, 100);
                const xpGained = currentEnemy.xpReward;
                
                if (isFirebaseActive) {
                    try {
                        const userDocRef = doc(db, `/artifacts/${appId}/users/${userId}/data/game-data`);
                        await runTransaction(db, async (transaction) => {
                            const userDoc = await transaction.get(userDocRef);
                            const data = userDoc.data();
                            
                            let newMoney = (data.money || 0) + moneyGained;
                            let newXp = (data.xp || 0) + xpGained;
                            let newLevel = data.level || 1;
                            let newXpToNextLevel = data.xpToNextLevel || 100;
                            let levelUp = false;

                            while (newXp >= newXpToNextLevel) {
                                newXp -= newXpToNextLevel;
                                newLevel++;
                                newXpToNextLevel = newLevel * 100;
                                levelUp = true;
                            }

                            transaction.update(userDocRef, { money: newMoney, xp: newXp, level: newLevel, xpToNextLevel: newXpToNextLevel });
                            
                            // Update local state after transaction
                            userMoney = newMoney;
                            userXp = newXp;
                            userLevel = newLevel;
                            xpToNextLevel = newXpToNextLevel;

                            const xpEarnedMessage = document.getElementById('xp-earned-message');
                            const levelUpMessage = document.getElementById('level-up-message');

                            xpEarnedMessage.textContent = `You earned ${xpGained} XP!`;
                            if (levelUp) {
                                levelUpMessage.textContent = `You leveled up to Level ${userLevel}!`;
                            } else {
                                levelUpMessage.textContent = '';
                            }
                        });
                        console.log("Stats updated successfully.");
                    } catch (e) {
                        console.error("Transaction failed: ", e);
                    }
                } else {
                    // Offline mode update
                    userMoney += moneyGained;
                    userXp += xpGained;
                    let levelUp = false;
                    while (userXp >= xpToNextLevel) {
                         userXp -= xpToNextLevel;
                         userLevel++;
                         xpToNextLevel = userLevel * 100;
                         levelUp = true;
                    }
                    localStorage.setItem('userData', JSON.stringify({
                        ...userData,
                        money: userMoney,
                        xp: userXp,
                        level: userLevel,
                        xpToNextLevel: xpToNextLevel
                    }));

                    const xpEarnedMessage = document.getElementById('xp-earned-message');
                    const levelUpMessage = document.getElementById('level-up-message');
                    xpEarnedMessage.textContent = `You earned ${xpGained} XP!`;
                    if (levelUp) {
                        levelUpMessage.textContent = `You leveled up to Level ${userLevel}!`;
                    } else {
                        levelUpMessage.textContent = '';
                    }
                }
                
                winMessage.textContent = message;
                moneyEarned.textContent = `$${moneyGained}`;
                winModal.style.display = 'flex';
            } else {
                showMessage(message);
                const restartButton = document.getElementById('restart-button');
                if (restartButton) restartButton.classList.remove('hidden');
            }
        }

        // --- Firebase Initialization & Event Listeners ---
        let statsUnsubscribe = null;
        let deckUnsubscribe = null;
        let userData = {
            money: 0,
            ownedCards: allCards.filter(c => c.purchaseCost === 0).map(c => c.id),
            inDeck: allCards.filter(c => c.purchaseCost === 0).map(c => c.id),
            level: 1,
            xp: 0,
            xpToNextLevel: 100,
            damageUpgradeLevel: 0,
            hpUpgradeLevel: 0
        };

        const listenToStats = () => {
            if (!isFirebaseActive) {
                const storedData = JSON.parse(localStorage.getItem('userData'));
                if (storedData) {
                    userData = storedData;
                    userMoney = userData.money;
                    userLevel = userData.level;
                    userXp = userData.xp;
                    xpToNextLevel = userData.xpToNextLevel;
                    damageUpgradeLevel = userData.damageUpgradeLevel;
                    hpUpgradeLevel = userData.hpUpgradeLevel;
                }
                renderStatsPage();
                return;
            }

            if (statsUnsubscribe) {
                statsUnsubscribe();
            }
            
            const userDocRef = doc(db, `/artifacts/${appId}/users/${userId}/data/game-data`);

            statsUnsubscribe = onSnapshot(userDocRef, (docSnap) => {
                if (docSnap.exists()) {
                    userData = docSnap.data();
                    userMoney = userData.money || 0;
                    userLevel = userData.level || 1;
                    userXp = userData.xp || 0;
                    xpToNextLevel = userData.xpToNextLevel || 100;
                    damageUpgradeLevel = userData.damageUpgradeLevel || 0;
                    hpUpgradeLevel = userData.hpUpgradeLevel || 0;
                    renderStatsPage();
                } else {
                    const statsDisplay = document.getElementById('stats-section');
                    if (statsDisplay) statsDisplay.textContent = 'User data not found.';
                }
            });
        };
        
        const listenToDeck = () => {
             if (!isFirebaseActive) {
                const storedData = JSON.parse(localStorage.getItem('userData'));
                if (storedData) {
                    userDeck = storedData.inDeck;
                    userOwnedCards = storedData.ownedCards;
                }
                renderDeckPage();
                return;
             }
             
             if (deckUnsubscribe) {
                 deckUnsubscribe();
             }

             const userDocRef = doc(db, `/artifacts/${appId}/users/${userId}/data/game-data`);

             deckUnsubscribe = onSnapshot(userDocRef, (docSnap) => {
                 if (docSnap.exists()) {
                     const data = docSnap.data();
                     userDeck = data.inDeck || [];
                     userOwnedCards = data.ownedCards || [];
                     renderDeckPage();
                 }
             });
        }

        const renderStatsPage = () => {
            const moneyDisplay = document.getElementById('money-display');
            const levelDisplay = document.getElementById('level-display');
            const xpDisplay = document.getElementById('xp-display');
            const xpBar = document.getElementById('xp-bar');
            const damageUpgradeLevelEl = document.getElementById('damage-upgrade-level');
            const hpUpgradeLevelEl = document.getElementById('hp-upgrade-level');
            const damageUpgradeCostEl = document.getElementById('damage-upgrade-cost');
            const hpUpgradeCostEl = document.getElementById('hp-upgrade-cost');
            
            if (moneyDisplay) moneyDisplay.textContent = `Money: $${userMoney}`;
            if (levelDisplay) levelDisplay.textContent = `Level: ${userLevel}`;
            if (xpDisplay) xpDisplay.textContent = `XP: ${userXp} / ${xpToNextLevel}`;
            if (xpBar) xpBar.style.width = `${(userXp / xpToNextLevel) * 100}%`;
            
            if (damageUpgradeLevelEl) damageUpgradeLevelEl.textContent = damageUpgradeLevel;
            if (hpUpgradeLevelEl) hpUpgradeLevelEl.textContent = hpUpgradeLevel;
            
            const damageCost = getUpgradeCost(damageUpgradeLevel);
            const hpCost = getUpgradeCost(hpUpgradeLevel);
            
            if (damageUpgradeCostEl) damageUpgradeCostEl.textContent = `$${damageCost}`;
            if (hpUpgradeCostEl) hpUpgradeCostEl.textContent = `$${hpCost}`;

            const upgradeDamageBtn = document.getElementById('upgrade-damage-button');
            const upgradeHpBtn = document.getElementById('upgrade-hp-button');
            
            if (upgradeDamageBtn) {
                 if (userMoney < damageCost) upgradeDamageBtn.disabled = true;
                 else upgradeDamageBtn.disabled = false;
            }
            if (upgradeHpBtn) {
                 if (userMoney < hpCost) upgradeHpBtn.disabled = true;
                 else upgradeHpBtn.disabled = false;
            }
        };
        
        const renderDeckPage = () => {
            const inDeckContainer = document.getElementById('in-deck-cards');
            const ownedContainer = document.getElementById('owned-cards');
            const notOwnedContainer = document.getElementById('not-owned-cards');
            const deckSizeText = document.querySelector('#in-deck-container h3');
            
            if (!inDeckContainer || !ownedContainer || !notOwnedContainer) return;

            deckSizeText.textContent = `In Deck (${userDeck.length}/${DECK_MAX_SIZE})`;
            inDeckContainer.innerHTML = '';
            ownedContainer.innerHTML = '';
            notOwnedContainer.innerHTML = '';

            const ownedCardIds = new Set(userOwnedCards);
            const inDeckCardIds = new Set(userDeck);
            
            allCards.forEach(card => {
                const cardEl = document.createElement('div');
                cardEl.classList.add('deck-card');
                
                const cardIcon = document.createElement('i');
                card.icon.split(' ').forEach(cls => cardIcon.classList.add(cls));
                cardIcon.classList.add('deck-card-icon', card.color);
                
                const cardTitle = document.createElement('span');
                cardTitle.classList.add('deck-card-title');
                cardTitle.textContent = card.name;
                
                cardEl.appendChild(cardIcon);
                cardEl.appendChild(cardTitle);

                cardEl.addEventListener('mousemove', (e) => showTooltip(e, card));
                cardEl.addEventListener('mouseout', hideTooltip);

                if (inDeckCardIds.has(card.id)) {
                    inDeckContainer.appendChild(cardEl);
                    const removeButton = document.createElement('button');
                    removeButton.classList.add('card-action-button');
                    removeButton.textContent = '-';
                    removeButton.addEventListener('click', () => removeFromDeck(card.id));
                    cardEl.appendChild(removeButton);
                } else if (ownedCardIds.has(card.id)) {
                    ownedContainer.appendChild(cardEl);
                    if (userDeck.length < DECK_MAX_SIZE) {
                         const addButton = document.createElement('button');
                         addButton.classList.add('card-action-button', 'add-card-button');
                         addButton.textContent = '+';
                         addButton.addEventListener('click', () => addToDeck(card.id));
                         cardEl.appendChild(addButton);
                    }
                } else {
                    notOwnedContainer.appendChild(cardEl);
                    const buyButton = document.createElement('button');
                    buyButton.classList.add('buy-button');
                    buyButton.textContent = `$${card.purchaseCost}` + (card.requiredLevel > 1 ? ` (Lvl ${card.requiredLevel})` : '');
                    if (userMoney < card.purchaseCost || userLevel < card.requiredLevel) {
                        buyButton.disabled = true;
                        buyButton.style.opacity = '0.5';
                    } else {
                        buyButton.disabled = false;
                        buyButton.addEventListener('click', () => purchaseCard(card.id, card.purchaseCost));
                    }
                    cardEl.appendChild(buyButton);
                }
            });
        };

        const renderEnemiesPage = () => {
            const enemiesListContainer = document.getElementById('enemies-list');
            if (!enemiesListContainer) return;
            enemiesListContainer.innerHTML = '';

            Object.keys(enemies).forEach(enemyId => {
                const enemy = enemies[enemyId];
                const enemyCard = document.createElement('div');
                enemyCard.classList.add('section', 'items-center');
                enemyCard.innerHTML = `
                    <h3 class="text-xl font-bold">${enemy.name}</h3>
                    <i class="${enemy.icon} text-4xl mb-2"></i>
                    <p class="text-sm">Health: ${enemy.health}</p>
                    <p class="text-sm">XP: ${enemy.xpReward}</p>
                    <button class="section-button fight-button" data-enemy-id="${enemyId}">Fight ${enemy.name}</button>
                `;
                enemiesListContainer.appendChild(enemyCard);
            });

            document.querySelectorAll('.fight-button').forEach(button => {
                button.addEventListener('click', (e) => {
                    appContainer.dataset.selectedEnemy = e.target.dataset.enemyId;
                    renderUI('game');
                });
            });
        };

        const upgradeStat = async (stat) => {
            if (!isFirebaseActive) {
                console.warn("Upgrades not available in offline mode.");
                return;
            }

            try {
                const userDocRef = doc(db, `/artifacts/${appId}/users/${userId}/data/game-data`);
                await runTransaction(db, async (transaction) => {
                    const userDoc = await transaction.get(userDocRef);
                    const data = userDoc.data();
                    
                    if (stat === 'damage') {
                        const currentLevel = data.damageUpgradeLevel || 0;
                        const cost = getUpgradeCost(currentLevel);
                        if (data.money >= cost) {
                             transaction.update(userDocRef, { 
                                 money: data.money - cost,
                                 damageUpgradeLevel: currentLevel + 1
                             });
                        }
                    } else if (stat === 'hp') {
                         const currentLevel = data.hpUpgradeLevel || 0;
                         const cost = getUpgradeCost(currentLevel);
                         if (data.money >= cost) {
                             transaction.update(userDocRef, { 
                                 money: data.money - cost,
                                 hpUpgradeLevel: currentLevel + 1
                             });
                         }
                    }
                });
                console.log(`${stat} upgraded successfully.`);
            } catch (e) {
                console.error("Transaction failed: ", e);
            }
        };

        const addToDeck = async (cardId) => {
             if (!isFirebaseActive) {
                userDeck.push(cardId);
                localStorage.setItem('userData', JSON.stringify({...userData, inDeck: userDeck}));
                renderDeckPage();
                return;
             }
             const userDocRef = doc(db, `/artifacts/${appId}/users/${userId}/data/game-data`);
             const newDeck = [...userDeck, cardId];
             await updateDoc(userDocRef, { inDeck: newDeck });
        };
        
        const removeFromDeck = async (cardId) => {
             if (!isFirebaseActive) {
                userDeck = userDeck.filter(id => id !== cardId);
                localStorage.setItem('userData', JSON.stringify({...userData, inDeck: userDeck}));
                renderDeckPage();
                return;
             }
             const userDocRef = doc(db, `/artifacts/${appId}/users/${userId}/data/game-data`);
             const newDeck = userDeck.filter(id => id !== cardId);
             await updateDoc(userDocRef, { inDeck: newDeck });
        };
        
        const purchaseCard = async (cardId, cost) => {
            if (userMoney < cost) return;

            if (!isFirebaseActive) {
                userMoney -= cost;
                userOwnedCards.push(cardId);
                localStorage.setItem('userData', JSON.stringify({
                    ...userData,
                    money: userMoney,
                    ownedCards: userOwnedCards,
                }));
                renderDeckPage();
                renderStatsPage();
                return;
            }

            try {
                const userDocRef = doc(db, `/artifacts/${appId}/users/${userId}/data/game-data`);
                await runTransaction(db, async (transaction) => {
                    const userDoc = await transaction.get(userDocRef);
                    const newMoney = userDoc.data().money - cost;
                    const newOwnedCards = [...(userDoc.data().ownedCards || []), cardId];
                    transaction.update(userDocRef, { money: newMoney, ownedCards: newOwnedCards });
                });
                console.log("Card purchased successfully.");
            } catch (e) {
                console.error("Transaction failed: ", e);
            }
        };


        const initAuthAndGame = async () => {
            try {
                if (isFirebaseActive) {
                    if (initialAuthToken) {
                        await signInWithCustomToken(auth, initialAuthToken);
                    } else {
                        await signInAnonymously(auth);
                    }
                    userId = auth.currentUser.uid;
                    
                    const userDocRef = doc(db, `/artifacts/${appId}/users/${userId}/data/game-data`);
                    const userDocSnap = await getDoc(userDocRef);
                    if (!userDocSnap.exists()) {
                        const startingCardIds = allCards.filter(c => c.purchaseCost === 0).map(c => c.id);
                        await setDoc(userDocRef, { 
                            money: 0, 
                            ownedCards: startingCardIds,
                            inDeck: startingCardIds,
                            level: 1,
                            xp: 0,
                            xpToNextLevel: 100,
                            damageUpgradeLevel: 0,
                            hpUpgradeLevel: 0
                        });
                    } else {
                        const data = userDocSnap.data();
                        userDeck = data.inDeck || [];
                        userOwnedCards = data.ownedCards || [];
                        userMoney = data.money || 0;
                        userLevel = data.level || 1;
                        userXp = data.xp || 0;
                        xpToNextLevel = data.xpToNextLevel || 100;
                        damageUpgradeLevel = data.damageUpgradeLevel || 0;
                        hpUpgradeLevel = data.hpUpgradeLevel || 0;
                    }
                } else {
                    const storedData = JSON.parse(localStorage.getItem('userData'));
                    if (storedData) {
                        userData = storedData;
                        userDeck = userData.inDeck;
                        userOwnedCards = userData.ownedCards;
                        userMoney = userData.money;
                        userLevel = userData.level;
                        userXp = userData.xp;
                        xpToNextLevel = userData.xpToNextLevel;
                        damageUpgradeLevel = userData.damageUpgradeLevel;
                        hpUpgradeLevel = userData.hpUpgradeLevel;
                    } else {
                        localStorage.setItem('userData', JSON.stringify(userData));
                    }
                }

                renderUI('main-menu');
                
            } catch (error) {
                console.error("Firebase authentication error:", error);
            }
        };

        function renderUI(page) {
            if (page === 'main-menu') {
                appContainer.innerHTML = createMainMenu();
                listenToStats();
                listenToDeck();
                addMainMenuEventListeners();
            } else if (page === 'game') {
                if (userDeck.length !== DECK_MAX_SIZE) {
                    const modal = document.createElement('div');
                    modal.classList.add('modal');
                    modal.innerHTML = `
                        <div class="modal-content">
                            <h2 class="text-2xl font-bold">Deck Size Error</h2>
                            <p>Your deck must contain exactly ${DECK_MAX_SIZE} cards to fight!</p>
                            <button class="modal-button" onclick="this.closest('.modal').style.display='none'">OK</button>
                        </div>
                    `;
                    document.body.appendChild(modal);
                    modal.style.display = 'flex';
                    return;
                }
                appContainer.innerHTML = createGamePage();
                const selectedEnemyId = appContainer.dataset.selectedEnemy;
                startGame(selectedEnemyId);
            }
        }

        function addMainMenuEventListeners() {
            const statsTabButton = document.getElementById('stats-tab-button');
            const enemiesTabButton = document.getElementById('enemies-tab-button');
            const deckTabButton = document.getElementById('deck-tab-button');
            const upgradeDamageBtn = document.getElementById('upgrade-damage-button');
            const upgradeHpBtn = document.getElementById('upgrade-hp-button');

            if (statsTabButton) statsTabButton.addEventListener('click', () => showTab('stats'));
            if (enemiesTabButton) enemiesTabButton.addEventListener('click', () => showTab('enemies'));
            if (deckTabButton) deckTabButton.addEventListener('click', () => showTab('deck'));

            if (upgradeDamageBtn) upgradeDamageBtn.addEventListener('click', () => upgradeStat('damage'));
            if (upgradeHpBtn) upgradeHpBtn.addEventListener('click', () => upgradeStat('hp'));

            function showTab(tabId) {
                const tabs = ['stats', 'enemies', 'deck'];
                tabs.forEach(tab => {
                    const tabSection = document.getElementById(`${tab}-section`);
                    const tabButton = document.getElementById(`${tab}-tab-button`);
                    if (tabSection) tabSection.classList.remove('active');
                    if (tabButton) tabButton.classList.remove('active');
                });

                const activeSection = document.getElementById(`${tabId}-section`);
                const activeButton = document.getElementById(`${tabId}-tab-button`);
                if (activeSection) activeSection.classList.add('active');
                if (activeButton) activeButton.classList.add('active');

                switch(tabId) {
                    case 'stats':
                        renderStatsPage();
                        break;
                    case 'enemies':
                        renderEnemiesPage();
                        break;
                    case 'deck':
                        renderDeckPage();
                        break;
                }
            }
        }
        
        winModalButton.addEventListener('click', () => {
            winModal.style.display = 'none';
            renderUI('main-menu');
        });

        window.onload = initAuthAndGame;
    </script>
</body>
</html>
